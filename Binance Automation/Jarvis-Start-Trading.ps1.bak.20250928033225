### JARVIS SINGLE-INSTANCE LOCK START ###
# Prevent multiple Jarvis instances. Creates journal\jarvis.lock; removes on exit.
try {
  $journalDir = Join-Path $PSScriptRoot 'journal'
  if (-not (Test-Path $journalDir)) { New-Item -ItemType Directory -Path $journalDir -Force | Out-Null }

  $lock = Join-Path $journalDir 'jarvis.lock'
  if (Test-Path $lock) {
    Write-Host "Jarvis already running (lock: $lock). Exiting."
    exit 0
  }

  New-Item -ItemType File -Path $lock -Force | Out-Null

  Register-EngineEvent PowerShell.Exiting -Action {
    try { Remove-Item $lock -ErrorAction SilentlyContinue } catch {}
  } | Out-Null

  $null = Register-ObjectEvent -InputObject $Host -EventName Exiting -Action {
    try { Remove-Item $lock -ErrorAction SilentlyContinue } catch {}
  }
} catch {
  $_ | Out-String | Add-Content (Join-Path $PSScriptRoot 'journal\jarvis.log')
  Write-Host "Failed to acquire single-instance lock: $_"
  exit 1
}
### JARVIS SINGLE-INSTANCE LOCK END ###
param(
  [switch] $Live,                       # add -Live to actually trade
  [double] $NotionalUSDT = 10,          # per pair BUY size in USDT
  [string] $Pairs = "BTCUSDT,ETHUSDT",  # comma-separated list
  [int]    $CooldownSec = 8,            # wait before SELL
  [string] $BaseUrl = $Env:BINANCE_BASE_URL
)
$ErrorActionPreference = 'Stop'

function Get-Signature([string]$query, [string]$secret) {
  $h = New-Object System.Security.Cryptography.HMACSHA256
  $h.Key = [Text.Encoding]::UTF8.GetBytes($secret)
  ($h.ComputeHash([Text.Encoding]::UTF8.GetBytes($query)) | % { $_.ToString('x2') }) -join ''
}

function Invoke-Binance {
  param(
    [string]$Method = 'GET',
    [string]$Path,
    [hashtable]$Query = @{},
    [switch]$Signed
  )
  $key    = $Env:BINANCE_API_KEY
  $secret = $Env:BINANCE_API_SECRET
  if (-not $BaseUrl) { $BaseUrl = 'https://api.binance.com' }
  if ([string]::IsNullOrWhiteSpace($key) -or [string]::IsNullOrWhiteSpace($secret)) {
    throw "Missing env keys. Set BINANCE_API_KEY / BINANCE_API_SECRET."
  }

  if ($Signed) {
    $Query.timestamp = [int64]([DateTimeOffset]::UtcNow.ToUnixTimeMilliseconds())
    $Query.recvWindow = 5000
  }

  $qs = ($Query.GetEnumerator() | Sort-Object Name | % { "{0}={1}" -f $_.Name, [uri]::EscapeDataString([string]$_.Value) }) -join "&"
  if ($Signed) { $qs = if ($qs) { "$qs&signature=$(Get-Signature $qs $secret)" } else { "signature=$(Get-Signature '' $secret)" } }

  $uri = if ($qs) { "$BaseUrl$Path`?$qs" } else { "$BaseUrl$Path" }
  $headers = @{ "X-MBX-APIKEY" = $key }

  switch ($Method) {
    'GET'    { return Invoke-RestMethod -Method GET    -Uri $uri -Headers $headers }
    'POST'   { return Invoke-RestMethod -Method POST   -Uri $uri -Headers $headers }
    'DELETE' { return Invoke-RestMethod -Method DELETE -Uri $uri -Headers $headers }
    default  { throw "Unsupported method $Method" }
  }
}

# Cache exchange info
if (-not $script:EXINFO) { $script:EXINFO = Invoke-Binance -Path '/api/v3/exchangeInfo' }
function Get-SymbolInfo([string]$symbol) { ($script:EXINFO.symbols | ? { $_.symbol -eq $symbol }) }

function Round-ToStep([double]$qty, [double]$step) {
  if ($step -le 0) { return [math]::Floor($qty * 1e8)/1e8 }
  $k = [math]::Floor($qty / $step)
  [double]("{0:G17}" -f ($k * $step))
}

function Get-Price([string]$symbol) {
  $d = Invoke-Binance -Path '/api/v3/ticker/price' -Query @{ symbol = $symbol }
  [double]$d.price
}

function Place-Market([string]$symbol, [ValidateSet('BUY','SELL')]$side, [double]$qty) {
  $q = @{
    symbol   = $symbol
    side     = $side
    type     = 'MARKET'
    quantity = "{0:G17}" -f $qty
  }
  if ($Live) {
    Invoke-Binance -Method 'POST' -Path '/api/v3/order' -Query $q -Signed
  } else {
    @{ dryRun = $false; symbol = $symbol; side=$side; quantity=$q.quantity }
  }
}

Write-Host ("=== JARVIS Starter Trading (DryRun={0}) ===" -f ([bool](-not $Live))) -ForegroundColor Cyan
Write-Host ("BaseUrl: {0} | Notional: {1} USDT | Pairs: {2}" -f $BaseUrl, $NotionalUSDT, $Pairs) -ForegroundColor DarkCyan

$pairList = $Pairs.Split(',') | % { $_.Trim().ToUpper() } | ? { $_ }
$priceCache = @{}

foreach ($sym in $pairList) {
  try {
    $info = Get-SymbolInfo $sym
    if (-not $info) { Write-Host ("{0}: not a spot symbol on this venue. Skipping." -f $sym) -ForegroundColor DarkYellow; continue }
    if ($info.status -ne 'TRADING') { Write-Host ("{0}: status {1}. Skipping." -f $sym, $info.status) -ForegroundColor DarkYellow; continue }

    $lot = $info.filters | ? { $_.filterType -eq 'LOT_SIZE' }
    $minQty = [double]$lot.minQty
    $step   = [double]$lot.stepSize

    $minNotF = $info.filters | ? { $_.filterType -eq 'MIN_NOTIONAL' }
    $minNot  = if ($minNotF) { [double]$minNotF.minNotional } else { 0.0 }

    if (-not $priceCache.ContainsKey($sym)) { $priceCache[$sym] = Get-Price $sym }
    $px = $priceCache[$sym]
    if ($px -le 0) { Write-Host ("{0}: bad price {1}. Skipping." -f $sym, $px) -ForegroundColor DarkYellow; continue }

    $qtyRaw  = $NotionalUSDT / $px
    $qtyStep = Round-ToStep $qtyRaw $step
    if ($qtyStep -lt $minQty) { Write-Host ("{0}: qty {1} < minQty {2}. Raise notional." -f $sym, $qtyStep, $minQty) -ForegroundColor DarkYellow; continue }
    if ($qtyStep * $px -lt $minNot) { Write-Host ("{0}: notional {1} < minNotional {2}. Raise notional." -f $sym, [math]::Round($qtyStep*$px,4), $minNot) -ForegroundColor DarkYellow; continue }

    $buy = Place-Market -symbol $sym -side 'BUY' -qty $qtyStep
    Write-Host ("{0}: BUY {1} @ ~{2} (â‰ˆ {3} USDT) [{4}]" -f $sym, $qtyStep, $px, [math]::Round($qtyStep*$px,2), ($Live ? "EXECUTED" : "DRYRUN")) -ForegroundColor Green

    Start-Sleep -Seconds $CooldownSec

    $sell = Place-Market -symbol $sym -side 'SELL' -qty $qtyStep
    Write-Host ("{0}: SELL {1} @ mkt [{2}]" -f $sym, $qtyStep, ($Live ? "EXECUTED" : "DRYRUN")) -ForegroundColor Green

  } catch {
    Write-Host ("{0}: ERROR - {1}" -f $sym, $_.Exception.Message) -ForegroundColor Red
    if ($_.ErrorDetails.Message) { Write-Host $_.ErrorDetails.Message -ForegroundColor Yellow }
  }
}

Write-Host "`nDone." -ForegroundColor Cyan

