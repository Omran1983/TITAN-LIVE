function isoNow() { return new Date().toISOString(); }
function minsDiff(a, b) { return (new Date(b) - new Date(a)) / 60000; }

async function tgSend(env, chatId, text) {
  const token = env?.TELEGRAM_BOT_TOKEN;
  if (!token || !chatId) return { ok:false, note:'tg not configured' };
  const api = `https://api.telegram.org/bot${token}/sendMessage`;
  const resp = await fetch(api, {
    method: 'POST',
    headers: { 'content-type': 'application/json' },
    body: JSON.stringify({ chat_id: chatId, text })
  });
  return { ok: resp.ok, status: resp.status };
}

async function safeTg(env, chatId, text) {
  try {
    const r = await tgSend(env, chatId, text);
    if (!r.ok && env?.AUDIT) {
      await env.AUDIT.put(`tg_warn:${Date.now()}`, JSON.stringify({ at:'tgSend', status:r.status }), { expirationTtl: 2592000 });
    }
  } catch (e) {
    try {
      await env.AUDIT.put(`tg_err:${Date.now()}`, JSON.stringify({ at:'tgSend', err:String(e) }), { expirationTtl: 2592000 });
    } catch {}
  }
}

async function supabaseDaily(env) {
  if (!env.SUPABASE_URL || !env.SUPABASE_ANON_KEY) {
    return { ok:false, note:'SUPABASE not configured' };
  }
  try {
    const base = env.SUPABASE_URL.replace(/\/+$/, '');
    const url = `${base}/rest/v1/rpc/daily_summary`;
    const resp = await fetch(url, {
      method: 'POST',
      headers: {
        'apikey': env.SUPABASE_ANON_KEY,
        'Authorization': `Bearer ${env.SUPABASE_ANON_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({})
    });
    let data = null;
    try { data = await resp.json(); } catch {}
    if (Array.isArray(data) && data.length === 1) data = data[0];
    return resp.ok ? (data || { ok:true }) : { ok:false, http:resp.status, data };
  } catch (e) {
    return { ok:false, err:String(e) };
  }
}

async function runCron(env) {
  const now = isoNow();
  let prev = null;
  try { prev = await env.STATUS.get('last_heartbeat', { type: 'text' }); } catch {}
  if (prev) {
    const gap = minsDiff(prev, now);
    if (gap > 10 && env.OWNER_CHAT_ID) {
      await safeTg(env, env.OWNER_CHAT_ID, `HQ-Lite ALERT: cron gap ~${gap.toFixed(1)} min (prev=${prev})`);
      try { await env.AUDIT.put(`cron_alert:${Date.now()}`, JSON.stringify({ prev, now, gap }), { expirationTtl: 2592000 }); } catch {}
    }
  }
  try { await env.STATUS.put('last_heartbeat', now); } catch {}
  try { await env.AUDIT.put('last_cron', now, { expirationTtl: 2592000 }); } catch {}
  return { ok:true, prev, now };
}

function fmt(v){ return (v===null||v===undefined)?'n/a':String(v); }

async function dailyPing(env) {
  let hb = null;
  try { hb = await env.STATUS.get('last_heartbeat', { type: 'text' }); } catch {}
  const sb = await supabaseDaily(env);
  const lines = [
    'EduConnect Dev Report',
    '',
    `Heartbeat: ${hb ?? 'n/a'}`,
    `Users:  ${fmt(sb.users)}`,
    `Orders: ${fmt(sb.orders)}`,
    `Tasks:  ${fmt(sb.tasks)}`,
    `Errors: ${fmt(sb.errors)}`
  ];
  const msg = lines.join('\n');
  if (env.OWNER_CHAT_ID) { await safeTg(env, env.OWNER_CHAT_ID, msg); }
  try { await env.AUDIT.put(`daily_ping:${Date.now()}`, isoNow(), { expirationTtl: 2592000 }); } catch {}
  return { ok:true, last_heartbeat: hb ?? null, supabase: sb };
}

async function versionInfo(env) {
  let hb = null;
  try { hb = await env.STATUS.get('last_heartbeat', { type: 'text' }); } catch {}
  return { ok:true, deploy_id: env.DEPLOY_ID ?? null, wrangler: env.WRANGLER_VERSION ?? null, last_heartbeat: hb ?? null };
}

export default {
  async fetch(request, env, ctx) {
    const url = new URL(request.url);
    try {
      if (url.pathname === '/tg/webhook' && request.method === 'POST') {
        const update = await request.json().catch(() => ({}));
        const msg = update?.message || update?.edited_message;
        const chatId = msg?.chat?.id;
        const text = (msg?.text || '').trim();
        if (text?.startsWith('/status')) {
          const hb = await env.STATUS.get('last_heartbeat', { type: 'text' }).catch(()=>null);
          await safeTg(env, chatId, `HQ-Lite OK\nlast_heartbeat: ${hb ?? 'n/a'}`);
        }
        if (text?.startsWith('/ping')) {
          await safeTg(env, chatId, 'pong');
        }
        if (text?.startsWith('/version')) {
          const v = await versionInfo(env);
          await safeTg(env, chatId, `DEPLOY=${v.deploy_id ?? 'n/a'}\n${v.wrangler ?? ''}\nlast_heartbeat: ${v.last_heartbeat ?? 'n/a'}`);
        }
        if (text?.startsWith('/report')) {
          await dailyPing(env);
          await safeTg(env, chatId, 'Sent: EduConnect Dev Report');
        }
        return new Response('ok', { status: 200 });
      }

      if (url.pathname === '/health') {
        const hb = await env.STATUS.get('last_heartbeat', { type: 'text' }).catch(()=>null);
        return new Response(JSON.stringify({ ok:true, last_heartbeat: hb ?? null }), { headers: { 'content-type': 'application/json' } });
      }

      if (url.pathname === '/cron/run') {
        const res = await runCron(env);
        return new Response(JSON.stringify(res), { headers: { 'content-type': 'application/json' } });
      }

      if (url.pathname === '/cron/ping') {
        const res = await dailyPing(env);
        return new Response(JSON.stringify(res), { headers: { 'content-type': 'application/json' } });
      }

      if (url.pathname === '/version') {
        const v = await versionInfo(env);
        return new Response(JSON.stringify(v), { headers: { 'content-type': 'application/json' } });
      }

      return new Response('OK', { status: 200 });
    } catch (e) {
      try { await env.AUDIT.put(`unhandled:${Date.now()}`, JSON.stringify({ err:String(e), path:url.pathname }), { expirationTtl: 2592000 }); } catch {}
      return new Response(JSON.stringify({ ok:false, error:String(e) }), { status: 500, headers: { 'content-type': 'application/json' } });
    }
  },

  async scheduled(event, env, ctx) {
    ctx.waitUntil(runCron(env));
    if (event?.cron === '0 5 * * *') {
      ctx.waitUntil(dailyPing(env));
    }
  }
};
