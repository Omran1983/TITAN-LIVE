<#
Harvis-Loop.ps1 ? resilient build loop (smart project + build detection)

? Project detection:
    1) $ProjectPath if it has package.json AND a known build strategy (scripts.build OR vite/next detection)
    2) Current directory if valid
    3) Nearby search (depth 4) for folders with package.json and a build strategy
    * Prefers paths matching "a-one-marcom"

? Git:
    - Skips if not a repo, no 'origin', offline, or -NoGit
    - Retries pull with backoff when safe

? NPM:
    - If lockfile exists ? npm ci
    - Else ? npm install

? Build:
    - If scripts.build exists ? npm run build
    - Else if vite detected (vite.config.* or devDep) ? npx vite build
    - Else if next detected (next.config.* or devDep) ? npx next build
    - Else ? throw (no build strategy)

? Kill-switch robust array handling
#>

param(
  [string]$ProjectPath = "F:\AION-ZERO\a-one-marcom",
  [string]$LogDir      = "F:\AION-ZERO\logs",
  [string]$Branch      = "main",
  [int]   $GitRetries  = 3,
  [switch]$NoGit,
  [switch]$Quiet
)

if ($PSVersionTable.PSVersion.Major -ge 7) { $global:PSNativeCommandUseErrorActionPreference = $false }

if (-not (Test-Path $LogDir)) { New-Item -ItemType Directory -Force -Path $LogDir | Out-Null }
$Log = Join-Path $LogDir ("harvis_{0:yyyyMMdd_HHmmss}.log" -f (Get-Date))
$StatusPath     = Join-Path $LogDir 'harvis_status.txt'
$KillSwitchPath = Join-Path $LogDir 'harvis_killswitch.json'

function ts { (Get-Date).ToString('o') }
function Write-Log { param([string]$Message,[switch]$Error)
  $line = "$(ts) | $Message"
  if ($Error) { $line | Tee-Object -FilePath $Log -Append | Write-Error }
  else { $line | Tee-Object -FilePath $Log -Append | Out-Host }
}

function Register-FailureAndMaybeTripKillSwitch {
  param([string]$Why = "unknown")
  try { $epochNow = [int][DateTimeOffset]::Now.ToUnixTimeSeconds() } catch { $epochNow = [int][double]::Parse((Get-Date -UFormat %s)) }
  $windowS=600; $limit=3
  $arr = $null
  if (Test-Path $KillSwitchPath) { try { $arr = Get-Content $KillSwitchPath -Raw | ConvertFrom-Json } catch { $arr = $null } }
  if ($null -eq $arr) { $arr = @() } elseif ($arr -isnot [System.Array]) { $arr = @($arr) }
  $arr += [pscustomobject]@{ t=$epochNow; why=$Why }
  $cut = $epochNow - $windowS
  $arr = $arr | Where-Object { $_ -ne $null -and $_.t -gt $cut }
  ($arr | ConvertTo-Json -Depth 3) | Set-Content -Path $KillSwitchPath -Encoding ASCII
  if ($arr.Count -ge $limit) { Set-Content -Path $StatusPath -Value 'degraded-offline'; Write-Log "Kill-switch tripped (>= $limit failures in 10m). Exiting." -Error; exit 2 }
}

function Test-Online { try { Test-NetConnection github.com -Port 443 -InformationLevel Quiet } catch { $false } }

function Invoke-Step { param([Parameter(Mandatory)][string]$Label,[Parameter(Mandatory)][string]$Exe,[string[]]$Args=@())
  Write-Log "$Label"
  & $Exe @Args 2>&1 | Tee-Object -FilePath $Log -Append
  if ($LASTEXITCODE -ne 0) { throw "$Label failed (exit=$LASTEXITCODE)" }
}

function Read-PackageJson {
  param([string]$Dir)
  $pj = Join-Path $Dir 'package.json'
  if (-not (Test-Path $pj)) { return $null }
  try { return (Get-Content $pj -Raw | ConvertFrom-Json) } catch { return $null }
}

function Detect-BuildStrategy {
  param([string]$Dir)
  $pkg = Read-PackageJson -Dir $Dir
  if ($pkg -ne $null) {
    if ($pkg.scripts -and $pkg.scripts.PSObject.Properties.Name -contains 'build') {
      return @{ kind='npm-script'; cmd=@('npm','run','build'); why='scripts.build' }
    }
    $devs = @()
    if ($pkg.devDependencies) { $devs += $pkg.devDependencies.PSObject.Properties.Name }
    if ($pkg.dependencies)    { $devs += $pkg.dependencies.PSObject.Properties.Name }
    $hasVite = ($devs -contains 'vite') -or (Test-Path (Join-Path $Dir 'vite.config.ts')) -or (Test-Path (Join-Path $Dir 'vite.config.js'))
    if ($hasVite) { return @{ kind='vite'; cmd=@('npx','vite','build'); why='vite detected' } }
    $hasNext = ($devs -contains 'next') -or (Test-Path (Join-Path $Dir 'next.config.js')) -or (Test-Path (Join-Path $Dir 'next.config.mjs'))
    if ($hasNext) { return @{ kind='next'; cmd=@('npx','next','build'); why='next detected' } }
  }
  return $null
}

function Is-ValidProject {
  param([string]$Dir)
  $pj = Join-Path $Dir 'package.json'
  if (-not (Test-Path $pj)) { return $false }
  return ($null -ne (Detect-BuildStrategy -Dir $Dir))
}

function Find-Project {
  param([string]$Hint)
  # 1) Exact hint if valid
  if ($Hint -and (Test-Path $Hint) -and (Is-ValidProject -Dir $Hint)) { return (Resolve-Path $Hint).Path }
  # 2) Current dir if valid
  if (Is-ValidProject -Dir (Get-Location).Path) { return (Get-Location).Path }
  # 3) Search nearby (depth 4) for valid projects
  $roots = @()
  if ($Hint -and (Test-Path $Hint)) { $roots += (Resolve-Path $Hint).Path }
  $roots += (Get-Location).Path
  $roots = $roots | Select-Object -Unique
  $candidates = @()
  foreach ($r in $roots) {
    Get-ChildItem -Path $r -Directory -Recurse -Depth 4 -ErrorAction SilentlyContinue |
      ForEach-Object {
        if (Is-ValidProject -Dir $_.FullName) { $candidates += $_.FullName }
      }
  }
  $pref = $candidates | Where-Object { $_ -match 'a-one-marcom' } | Select-Object -First 1
  if ($pref) { return $pref }
  return ($candidates | Select-Object -First 1)
}

# ---------- Working directory ----------
$Pushed = $false
try {
  $work = Find-Project -Hint $ProjectPath
  if ($work) { Push-Location $work; $Pushed=$true; Write-Log "WorkingDir -> $work" } else { Write-Log "Staying in $(Get-Location) (no valid project found)"; throw "No valid JS project (package.json + build strategy) found." }

  $projName = (Split-Path (Get-Location) -Leaf)
  $Tag = "HARVIS | $($projName.ToUpper())"
  Set-Content -Path $StatusPath -Value 'starting'

  # ---------- GIT (optional; skip when unsafe) ----------
  $insideRepo = $false
  try { & git rev-parse --is-inside-work-tree 2>$null | Out-Null; $insideRepo = ($LASTEXITCODE -eq 0) } catch { $insideRepo = $false }
  $hasOrigin = $false
  if ($insideRepo) { & git remote get-url origin 2>$null | Out-Null; $hasOrigin = ($LASTEXITCODE -eq 0) }

  if ($NoGit) {
    Write-Log "$($Tag): -NoGit -> skipping git pull"
  } elseif (-not $insideRepo) {
    Write-Log "$($Tag): Not a git repo -> skipping git pull"
  } elseif (-not $hasOrigin) {
    Write-Log "$($Tag): No 'origin' remote -> skipping git pull"
  } elseif (-not (Test-Online)) {
    Write-Log "$($Tag): Offline -> skipping git pull"
  } else {
    $attempt=0; $code=0
    while ($attempt -lt [math]::Max(1,$GitRetries)) {
      & git fetch origin $Branch 2>&1 | Tee-Object -FilePath $Log -Append
      & git pull --rebase origin $Branch 2>&1 | Tee-Object -FilePath $Log -Append
      $code = $LASTEXITCODE
      if ($code -eq 0) { break }
      $backoff = [int](5 * [math]::Pow(2, $attempt))
      Write-Log "$($Tag): git pull failed (exit=$code). Retrying in ${backoff}s..."
      Start-Sleep -Seconds $backoff
      $attempt++
    }
    if ($code -ne 0) { throw "$($Tag): git pull failed after $attempt attempts (exit=$code)" }
  }

  # ---------- NPM ----------
  $hasLock = (Test-Path 'package-lock.json') -or (Test-Path 'npm-shrinkwrap.json')
  if ($hasLock) {
    Write-Log "$($Tag): npm ci"
    Invoke-Step -Label "$($Tag): npm ci" -Exe 'npm' -Args @('ci')
  } else {
    Write-Log "$($Tag): npm install (no lockfile)"
    Invoke-Step -Label "$($Tag): npm install" -Exe 'npm' -Args @('install')
  }

  # ---------- BUILD STRATEGY ----------
  $strategy = Detect-BuildStrategy -Dir (Get-Location).Path
  if ($null -eq $strategy) { throw "$($Tag): No build strategy discovered (no scripts.build, no vite/next config)" }
  Write-Log "$($Tag): build via $($strategy.kind) ($($strategy.why))"
  Invoke-Step -Label "$($Tag): build" -Exe $strategy.cmd[0] -Args $strategy.cmd[1..($strategy.cmd.Count-1)]

  Set-Content -Path $StatusPath -Value 'ok'
  if (-not $Quiet) { Write-Log "$($Tag): SUCCESS" }
}
catch {
  $msg = $_.Exception.Message
  Write-Log "ERROR | $msg" -Error
  Register-FailureAndMaybeTripKillSwitch -Why $msg
  Set-Content -Path $StatusPath -Value 'error'
  exit 1
}
finally {
  if ($Pushed) { Pop-Location }
}
